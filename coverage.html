
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>geoip: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Loyalsoldier/geoip/convert.go (18.2%)</option>
				
				<option value="file1">github.com/Loyalsoldier/geoip/list.go (25.0%)</option>
				
				<option value="file2">github.com/Loyalsoldier/geoip/lookup.go (36.6%)</option>
				
				<option value="file3">github.com/Loyalsoldier/geoip/main.go (0.0%)</option>
				
				<option value="file4">github.com/Loyalsoldier/geoip/merge.go (38.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "log"

        "github.com/Loyalsoldier/geoip/lib"
        "github.com/spf13/cobra"
)

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(convertCmd)
        convertCmd.PersistentFlags().StringP("config", "c", "config.json", "URI of the JSON format config file, support both local file path and remote HTTP(S) URL")
}</span>

var convertCmd = &amp;cobra.Command{
        Use:     "convert",
        Aliases: []string{"conv"},
        Short:   "Convert geoip data from one format to another by using config file",
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                configFile, _ := cmd.Flags().GetString("config")
                log.Println("Use config:", configFile)

                instance, err := lib.NewInstance()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">if err := instance.InitConfig(configFile); err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">if err := instance.Run(); err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
        },
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "github.com/Loyalsoldier/geoip/lib"
        "github.com/spf13/cobra"
)

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(listCmd)
}</span>

var listCmd = &amp;cobra.Command{
        Use:     "list",
        Aliases: []string{"l", "ls"},
        Short:   "List all available input and output formats",
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                lib.ListInputConverter()
                println()
                lib.ListOutputConverter()
        }</span>,
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "bufio"
        "fmt"
        "log"
        "net/netip"
        "os"
        "strings"

        "github.com/Loyalsoldier/geoip/lib"
        "github.com/Loyalsoldier/geoip/plugin/maxmind"
        "github.com/Loyalsoldier/geoip/plugin/mihomo"
        "github.com/Loyalsoldier/geoip/plugin/plaintext"
        "github.com/Loyalsoldier/geoip/plugin/singbox"
        "github.com/Loyalsoldier/geoip/plugin/special"
        "github.com/Loyalsoldier/geoip/plugin/v2ray"
        "github.com/spf13/cobra"
)

var supportedInputFormats = map[string]bool{
        strings.ToLower("clashRuleSet"):          true,
        strings.ToLower("clashRuleSetClassical"): true,
        strings.ToLower("dbipCountryMMDB"):       true,
        strings.ToLower("ipinfoCountryMMDB"):     true,
        strings.ToLower("maxmindMMDB"):           true,
        strings.ToLower("mihomoMRS"):             true,
        strings.ToLower("singboxSRS"):            true,
        strings.ToLower("surgeRuleSet"):          true,
        strings.ToLower("text"):                  true,
        strings.ToLower("v2rayGeoIPDat"):         true,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(lookupCmd)

        lookupCmd.Flags().StringP("format", "f", "", "(Required) The input format. Available formats: text, v2rayGeoIPDat, maxmindMMDB, dbipCountryMMDB, ipinfoCountryMMDB, mihomoMRS, singboxSRS, clashRuleSet, clashRuleSetClassical, surgeRuleSet")
        lookupCmd.Flags().StringP("uri", "u", "", "URI of the input file, support both local file path and remote HTTP(S) URL. (Cannot be used with \"dir\" flag)")
        lookupCmd.Flags().StringP("dir", "d", "", "Path to the input directory. The filename without extension will be as the name of the list. (Cannot be used with \"uri\" flag)")
        lookupCmd.Flags().StringSliceP("searchlist", "l", []string{}, "The lists to search from, separated by comma")

        lookupCmd.MarkFlagRequired("format")
        lookupCmd.MarkFlagsOneRequired("uri", "dir")
        lookupCmd.MarkFlagsMutuallyExclusive("uri", "dir")
        lookupCmd.MarkFlagDirname("dir")
}</span>

var lookupCmd = &amp;cobra.Command{
        Use:     "lookup",
        Aliases: []string{"find"},
        Short:   "Lookup if specified IP or CIDR is in specified lists",
        Args:    cobra.RangeArgs(0, 1),
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                // Validate format
                format, _ := cmd.Flags().GetString("format")
                format = strings.ToLower(strings.TrimSpace(format))
                if _, found := supportedInputFormats[format]; !found </span><span class="cov0" title="0">{
                        log.Fatal("unsupported input format")
                }</span>

                // Set name
                <span class="cov0" title="0">name := "true"

                // Get uri
                uri, _ := cmd.Flags().GetString("uri")

                // Get dir
                dir, _ := cmd.Flags().GetString("dir")

                // Get searchlist
                searchList, _ := cmd.Flags().GetStringSlice("searchlist")

                switch len(args) &gt; 0 </span>{
                case true:<span class="cov0" title="0"> // With search arg, run in once mode
                        search := strings.ToLower(strings.TrimSpace(args[0]))
                        if !isValidIPOrCIDR(search) </span><span class="cov0" title="0">{
                                fmt.Println("false")
                                return
                        }</span>

                        <span class="cov0" title="0">instance, err := lib.NewInstance()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatal(err)
                        }</span>

                        <span class="cov0" title="0">instance.AddInput(getInputForLookup(format, name, uri, dir))
                        instance.AddOutput(getOutputForLookup(search, searchList...))

                        if err := instance.Run(); err != nil </span><span class="cov0" title="0">{
                                log.Fatal(err)
                        }</span>

                case false:<span class="cov0" title="0"> // No search arg, run in REPL mode
                        instance, err := lib.NewInstance()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatal(err)
                        }</span>
                        <span class="cov0" title="0">instance.AddInput(getInputForLookup(format, name, uri, dir))

                        container := lib.NewContainer()
                        if err := instance.RunInput(container); err != nil </span><span class="cov0" title="0">{
                                log.Fatal(err)
                        }</span>

                        <span class="cov0" title="0">fmt.Println(`Enter IP or CIDR (type "exit" to quit):`)
                        fmt.Print("&gt;&gt; ")

                        scanner := bufio.NewScanner(os.Stdin)
                        for scanner.Scan() </span><span class="cov0" title="0">{
                                search := strings.ToLower(strings.TrimSpace(scanner.Text()))
                                if search == "" </span><span class="cov0" title="0">{
                                        fmt.Println()
                                        fmt.Print("&gt;&gt; ")
                                        continue</span>
                                }
                                <span class="cov0" title="0">if search == "exit" || search == `"exit"` </span><span class="cov0" title="0">{
                                        break</span>
                                }

                                <span class="cov0" title="0">if !isValidIPOrCIDR(search) </span><span class="cov0" title="0">{
                                        fmt.Println("false")
                                        fmt.Println()
                                        fmt.Print("&gt;&gt; ")
                                        continue</span>
                                }

                                <span class="cov0" title="0">instance.ResetOutput()
                                instance.AddOutput(getOutputForLookup(search, searchList...))

                                if err := instance.RunOutput(container); err != nil </span><span class="cov0" title="0">{
                                        log.Fatal(err)
                                }</span>

                                <span class="cov0" title="0">fmt.Println()
                                fmt.Print("&gt;&gt; ")</span>
                        }
                        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                                log.Fatal(err)
                        }</span>
                }
        },
}

// Check if the input is a valid IP or CIDR
func isValidIPOrCIDR(search string) bool <span class="cov8" title="1">{
        if search == "" </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">var err error
        switch strings.Contains(search, "/") </span>{
        case true:<span class="cov8" title="1"> // CIDR
                _, err = netip.ParsePrefix(search)</span>
        case false:<span class="cov8" title="1"> // IP
                _, err = netip.ParseAddr(search)</span>
        }

        <span class="cov8" title="1">return err == nil</span>
}

func getInputForLookup(format, name, uri, dir string) lib.InputConverter <span class="cov8" title="1">{
        var input lib.InputConverter

        switch strings.ToLower(format) </span>{
        case strings.ToLower(maxmind.TypeGeoLite2CountryMMDBIn):<span class="cov8" title="1">
                input = &amp;maxmind.GeoLite2CountryMMDBIn{
                        Type:        maxmind.TypeGeoLite2CountryMMDBIn,
                        Action:      lib.ActionAdd,
                        Description: maxmind.DescGeoLite2CountryMMDBIn,
                        URI:         uri,
                }</span>

        case strings.ToLower(maxmind.TypeDBIPCountryMMDBIn):<span class="cov8" title="1">
                input = &amp;maxmind.GeoLite2CountryMMDBIn{
                        Type:        maxmind.TypeDBIPCountryMMDBIn,
                        Action:      lib.ActionAdd,
                        Description: maxmind.DescDBIPCountryMMDBIn,
                        URI:         uri,
                }</span>

        case strings.ToLower(maxmind.TypeIPInfoCountryMMDBIn):<span class="cov8" title="1">
                input = &amp;maxmind.GeoLite2CountryMMDBIn{
                        Type:        maxmind.TypeIPInfoCountryMMDBIn,
                        Action:      lib.ActionAdd,
                        Description: maxmind.DescIPInfoCountryMMDBIn,
                        URI:         uri,
                }</span>

        case strings.ToLower(mihomo.TypeMRSIn):<span class="cov8" title="1">
                input = &amp;mihomo.MRSIn{
                        Type:        mihomo.TypeMRSIn,
                        Action:      lib.ActionAdd,
                        Description: mihomo.DescMRSIn,
                        Name:        name,
                        URI:         uri,
                        InputDir:    dir,
                }</span>

        case strings.ToLower(singbox.TypeSRSIn):<span class="cov8" title="1">
                input = &amp;singbox.SRSIn{
                        Type:        singbox.TypeSRSIn,
                        Action:      lib.ActionAdd,
                        Description: singbox.DescSRSIn,
                        Name:        name,
                        URI:         uri,
                        InputDir:    dir,
                }</span>

        case strings.ToLower(v2ray.TypeGeoIPDatIn):<span class="cov8" title="1">
                input = &amp;v2ray.GeoIPDatIn{
                        Type:        v2ray.TypeGeoIPDatIn,
                        Action:      lib.ActionAdd,
                        Description: v2ray.DescGeoIPDatIn,
                        URI:         uri,
                }</span>

        case strings.ToLower(plaintext.TypeTextIn):<span class="cov8" title="1">
                input = &amp;plaintext.TextIn{
                        Type:        plaintext.TypeTextIn,
                        Action:      lib.ActionAdd,
                        Description: plaintext.DescTextIn,
                        Name:        name,
                        URI:         uri,
                        InputDir:    dir,
                }</span>

        case strings.ToLower(plaintext.TypeClashRuleSetIPCIDRIn):<span class="cov8" title="1">
                input = &amp;plaintext.TextIn{
                        Type:        plaintext.TypeClashRuleSetIPCIDRIn,
                        Action:      lib.ActionAdd,
                        Description: plaintext.DescClashRuleSetIPCIDRIn,
                        Name:        name,
                        URI:         uri,
                        InputDir:    dir,
                }</span>

        case strings.ToLower(plaintext.TypeClashRuleSetClassicalIn):<span class="cov8" title="1">
                input = &amp;plaintext.TextIn{
                        Type:        plaintext.TypeClashRuleSetClassicalIn,
                        Action:      lib.ActionAdd,
                        Description: plaintext.DescClashRuleSetClassicalIn,
                        Name:        name,
                        URI:         uri,
                        InputDir:    dir,
                }</span>

        case strings.ToLower(plaintext.TypeSurgeRuleSetIn):<span class="cov8" title="1">
                input = &amp;plaintext.TextIn{
                        Type:        plaintext.TypeSurgeRuleSetIn,
                        Action:      lib.ActionAdd,
                        Description: plaintext.DescSurgeRuleSetIn,
                        Name:        name,
                        URI:         uri,
                        InputDir:    dir,
                }</span>

        default:<span class="cov0" title="0">
                log.Fatal("unsupported input format")</span>
        }

        <span class="cov8" title="1">return input</span>
}

func getOutputForLookup(search string, searchList ...string) lib.OutputConverter <span class="cov8" title="1">{
        return &amp;special.Lookup{
                Type:        special.TypeLookup,
                Action:      lib.ActionOutput,
                Description: special.DescLookup,
                Search:      search,
                SearchList:  searchList,
        }
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "log"

        "github.com/spf13/cobra"
)

var rootCmd = &amp;cobra.Command{
        Use:   "geoip",
        Short: "geoip is a convenient tool to merge, convert and lookup IP &amp; CIDR from various formats of geoip data.",
        CompletionOptions: cobra.CompletionOptions{
                HiddenDefaultCmd: true,
        },
}

func main() <span class="cov0" title="0">{
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "log"
        "strings"

        "github.com/Loyalsoldier/geoip/lib"
        "github.com/Loyalsoldier/geoip/plugin/special"
        "github.com/spf13/cobra"
)

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(mergeCmd)
        mergeCmd.PersistentFlags().StringP("onlyiptype", "t", "", "The only IP type to output, available options: \"ipv4\", \"ipv6\"")
}</span>

var mergeCmd = &amp;cobra.Command{
        Use:     "merge",
        Aliases: []string{"m"},
        Short:   "Merge plaintext IP &amp; CIDR from standard input, then print to standard output",
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                otype, _ := cmd.Flags().GetString("onlyiptype")
                otype = strings.ToLower(strings.TrimSpace(otype))

                if otype != "" &amp;&amp; otype != "ipv4" &amp;&amp; otype != "ipv6" </span><span class="cov0" title="0">{
                        log.Fatal("invalid argument onlyiptype: ", otype)
                }</span>

                <span class="cov0" title="0">instance, err := lib.NewInstance()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">instance.AddInput(getInputForMerge())
                instance.AddOutput(getOutputForMerge(otype))

                if err := instance.Run(); err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
        },
}

func getInputForMerge() lib.InputConverter <span class="cov8" title="1">{
        return &amp;special.Stdin{
                Type:        special.TypeStdin,
                Action:      lib.ActionAdd,
                Description: special.DescStdin,
                Name:        "temp",
        }
}</span>

func getOutputForMerge(otype string) lib.OutputConverter <span class="cov8" title="1">{
        switch lib.IPType(otype) </span>{
        case lib.IPv4:<span class="cov8" title="1">
                return &amp;special.Stdout{
                        Type:        special.TypeStdout,
                        Action:      lib.ActionOutput,
                        Description: special.DescStdout,
                        OnlyIPType:  lib.IPv4,
                }</span>

        case lib.IPv6:<span class="cov8" title="1">
                return &amp;special.Stdout{
                        Type:        special.TypeStdout,
                        Action:      lib.ActionOutput,
                        Description: special.DescStdout,
                        OnlyIPType:  lib.IPv6,
                }</span>

        default:<span class="cov8" title="1">
                return &amp;special.Stdout{
                        Type:        special.TypeStdout,
                        Action:      lib.ActionOutput,
                        Description: special.DescStdout,
                }</span>
        }

}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
